1.闭包
闭包就是函数嵌套函数可以访问其他函数变量内部作用域的函数变量

2.说说 new 操作符具体⼲了什么？
在 JavaScript 中， new 操作符⽤于创建⼀个给定构造函数的实例对象、、、、、、、、、、、、、、、、、、、、、、、、
new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性和原型链中的属性
（可以拿到原型链中的属性是因为实例与构造函数通过原型链连接了起来）

3.什么是面向对象
面向对象是一种编程思想，是相对于面向过程来说的，js 中一切皆对象。
对象包含两个含义，一个是属性，另外一个是动作。对象则是属性和动作的结合体。
把描述这个对象的东西看作这个对象的属性
方法是指对象能够进行的操作，方法同时还有另外一个名称，叫做函数
一个对象包含属性和方法 属性是私有的 方法是共享的

 4.什么是原型，原型链
隐式原型**proto**
每一个实例都有隐式原型 指向的就是构造函数的显式原型
显式原型prototype
构造函数都有显式原型 在原型上放的就是能够被所有的实例化对象所共享的属性和方法
constructor
这个单词本事是构造函数的意思，每一个 prototype 上都有一个 constructor，指向构造函数本身
原型对象也可能拥有原型，并从中继承⽅法和属性，⼀层⼀层、以此类推。这种关系常被称为原型链
(prototype chain)，它解释了为何⼀个对象会拥有定义在其他对象中的属性和⽅法
自己有就用自己的 自己没有就用继承的 最终会找到 Object

 5.Javascript 如何实现继承?
JS 继承实现⽅式也很多，主要分 ES5 和 ES6
ES5 实现继承主要是基于 prototype 来实现的，具体有三种⽅法
⼀是原型链继承：即 B.prototype=new A()（只能继承原型上的不能继承构造函数里的）
⼆是借⽤构造函数继承(call 或者 apply 的⽅式继承) （只能继承构造函数里的不能继承原型）
function B(name,age) {
A.call(this,name,age)
}
三是组合继承
组合继承就是结合第⼀种和第⼆种⽅式

6.事件循环，同步异步，宏任务微任务
JavaScript 是⼀⻔单线程的语⾔，意味着同⼀时间内只能做⼀件事，⽽实现单线程⾮阻塞的⽅法就是事件循环（event loop）
在 JavaScript 中，所有的任务都可以分为同步异步，宏任务微任务
 同步任务：⽴即执⾏的任务，同步任务⼀般会直接进⼊到主线程中执⾏
 异步任务：异步执⾏的任务，⽐如 ajax ⽹络请求， setTimeout 定时函数等 异步任务会进入任务队列进行等待
 异步执行的时机是同步代码执行完了 异步任务准备好才会执行异步任务
   异步任务 ：又分为宏任务微任务
   宏任务 计时器 ajax 请求
   微任务 promise.then()
在异步任务中 微任务先执行 宏任务后执行

7.说说 JavaScript 中的数据类型？存储上的差别？
JavaScript 中，我们可以分成两种类型：基本类型 复杂类型
区别是：存储位置不同：
基本数据类型存储在栈中
引⽤类型的对象存储于堆中
基本类型主要为以下 6 种：Number，String，Boolean，Undefined，null，symbol
引⽤类型，复杂类型统称为 Object ，我们这⾥主要讲述下⾯三种：Object，Array，Functio

8.数据类型的判断
数据类型判断大概有四种 typeof、instanceof、constructor（康四处阿克特）、Object.prototype.toString.call()
typeof 检测数据类型会返回对应的数据类型小写字符。
instanceof 运算符需要指定一个构造函数，它用来判断这个构造函数的原型是否在给定对象的原型链上
constructor 是 prototype 对象上的属性，指向构造函数。我们可以用实例的隐式原型去找到构造函数的值
通过 toString() 来获取每个对象的类型。每个对象都能通过 Object.prototype.toString() 来检测

 9. bind、call、apply 区别？
 apply 、 call 、 bind 三者的区别在于：
都可以改变函数的 this 对象指向
三者第⼀个参数都是 this 要指向的对象，如果没有这个参数为 undefined或 null ，则默认指向全局 window
三者都可以传参，但是 apply 是数组，⽽ call 是参数列表，且 apply 和 call 是⼀次性传⼊参数，⽽ bind 可以分为多次传⼊
bind 是返回绑定 this 之后的函数， apply 、 call 则是⽴即执⾏

10.存储
本地存储分为 cookie、localStorage、sessionStorage，
Cookie 设计初衷是用来和服务器通讯，而不是本地存储，他只是被‘借用’到本地存储。
Cookie 有一些缺点：存储空间小，最大 4k、用的时候比较麻烦
在 HTML5 中，新加入了一个 localStorage/sessionStorage 特性这个特性解决了 cookie 存储空间不足的问题
优点：HTML5 专门为存储而设计，最大可存 5M、API 简单易用 setItem getItem、不会随着 http 请求被发送出去
Cookie 可以设置过期时间 存储容量比较小 用起来没有方便的方法
localStorage 数据会永久存储，除非代码或手动删除（localStorage 只支持 string 类型的存储。）
sessionStroage 数据只存在于当前会话，浏览器关闭则清空

11.作⽤域
作⽤域，即变量和函数⽣效的范围
作用域分为：全局作用域和局部作用域
全局 在哪儿都能用的变量
局部作用域 只在某一个范围内能用的 （又分为函数作用域和块级作用域）

 12. This 的指向
在 js 中 this 不是固定不变的，它会随着执行环境的改变而改变。要注意的是 this 取什么值，是在执行时确认的，定义时无法确认
有三个方法改变 this：
call:参数是单个使用的，
apply:参数是一个数组
call 和 apply 都会立刻调用这个函数
bind:只改变 this 不会让函数立刻调用

13. 深拷贝 浅拷贝
深拷贝拷贝的是值 浅拷贝拷贝的是地址
深拷贝和浅拷贝的区别
浅拷贝： 将原对象的引用直接赋给新对象，新对象只是原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存
深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，
是“值”而不是“引用”，新对象跟原对象不共享内存，修改新对象不会改到原对象
基本数据类型存储在栈中
引⽤类型的对象存储于堆中

数组深拷贝的方法：
1.  可以用 JSON.parse(JSON.stringify())
2.  concat                       
3.  展开运算符
对象深拷贝的方法：
1. 可以用 JSON.parse(JSON.stringify())
2. 用递归实现

15. Jsonp 的原理
ajax 请求受同源策略影响，不允许进行请求，我们利用 script 标签的 src 属性不受同源策略的约束

16. dom 操作
一、dom 元素获取
document.getElementsByTagName()  通过标签来获取元素的对象, 返回值是一个数组
document.getElementsByClassName()  通过 class 类名来获取的对象,返回值是一个数组
document.getElementById(id 的值)  通过 id 来获取元素的对象，返回值是一个对象
二、dom 创建
 创建：新的标签(元素节点) = document.createElement("标签名")
 删除：父节点.removeChild(子节点);
 插入：insertBefore(新插入的节点，参照物节点) 往某个节点的前面插入一个新的节点
 追加：appendChild(新的节点的名) 当前对象追加一个子节点

 17.事件
事件绑定的方法
一是直接在标签内直接添加执行语句，二是绑定函数。第三种 是事件监听（addEventListener）
DOM 事件两种类型：事件捕获、事件冒泡。
    事件捕获就是由外往内，从事件发生的顶点开始，逐级往下查找，一直到目标元素。
    事件冒泡就是由内往外，从具体的目标节点元素触发，逐级向上传递，直到根节点

18.事件委托
事件委托，又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。
如果子元素阻止了事件冒泡，那么委托也就没法实现了

 19。封装一个通用的事件绑定函数
我们在封装这个函数的时候可以用事件监听来实现 ，封装的函数有三个参数，
第一个是要绑定事件的元素，第二个是要绑定的事件类型，第三个是事件的执行函数。
调用这个函数 就可以实现给某个元素绑定一个事件了。

 20. 数组方法 
reverse() 数组翻转
sort() 数组排序
join() 数组拼接
forEach 循环 没有 return 对原数组发生改变
filter 返回所有满足条件的新数组 返回值就是新数组
map 遍历数组，可重新构建一个新的数组 返回值就是新数组
find 查找数组中满足条件的第一个数组项 返回这个数组项
some 遍历数组中，数组中至少有一个满足条件的数组项，返回 true 否则 false
every 遍历数组 所有的数组项都满足条件时 返回 ture 否则 false

21. 数组去重 
1. 使用 ES6 中的 set 是最简单的去重方法
   let arr = [1, 2, 3, 4, 5, 5, 4, 3];
   let res = [...new Set(arr)];
2 递归去重
3.forEach+indexOf
   定义一个空数组，通过 forEach 循环，indexOf 判断值是否是-1，如果是 push 到新的数组中

22. 字符串的方法
charAt( ) 方法从一个字符串中返回某个下标上的字符
concat( ) 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。
search( ) 获取某个字符或者字符串片段首次出现的位置
match( ) 检索字符串或者正则表达式
replace( ) 替换  
replace(参数 1,参数 2); 参数 1：替换谁 参数 2：替换值
split( 参数 1,参数 2 ) 字符串切割，切割后返回数组
slice( ) 和 substring( ) ( 开始位置，结束位置 ) （包左不包右）

23.防抖节流
防抖：就是事件触发 n 秒之后在执行回调 如果 n 秒内再执行 则重新计算时间，若在 n 秒内重复触发，只有⼀次⽣效
节流：如果触发某个事件 每隔 n 秒执行一次
相同点： 都可以通过使⽤ setTimeout 实现 ⽬的都是，降低回调执⾏频率。节省计算资源
不同点：
函数防抖，在⼀段连续操作结束后，处理回调，利⽤ clearTimeout 和 setTimeout 实现。
函数节流，在⼀段连续操作中，每⼀段时间只执⾏⼀次，频率较⾼的事件中使⽤来提⾼性能。
防抖适合用在 表单提交或者表单搜索的场景
节流适合用在滚动条滚动事件

